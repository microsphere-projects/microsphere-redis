/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.microsphere.redis.generator.doclet;

import com.sun.source.doctree.DocCommentTree;
import com.sun.source.doctree.DocTree;
import com.sun.source.tree.CompilationUnitTree;
import com.sun.source.tree.MethodTree;
import com.sun.source.tree.Tree;
import com.sun.source.tree.TypeParameterTree;
import com.sun.source.tree.VariableTree;
import com.sun.source.util.DocTreeScanner;
import com.sun.source.util.DocTrees;
import com.sun.source.util.JavacTask;
import com.sun.source.util.TreeScanner;
import io.microsphere.logging.Logger;
import io.microsphere.redis.generator.doclet.logging.ReporterLoggerAdapter;
import io.microsphere.redis.generator.metadata.SpringDataRedisMetadataGenerator;
import io.microsphere.redis.metadata.RedisMetadata;
import io.microsphere.util.ValueHolder;
import jdk.javadoc.doclet.Doclet;
import jdk.javadoc.doclet.DocletEnvironment;
import jdk.javadoc.doclet.Reporter;
import org.springframework.data.redis.connection.RedisCommands;
import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.Yaml;

import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Name;
import javax.lang.model.element.NestingKind;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.ElementScanner9;
import javax.tools.JavaCompiler;
import javax.tools.JavaFileManager;
import javax.tools.JavaFileObject;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;

import static com.sun.source.doctree.DocTree.Kind.SEE;
import static io.microsphere.annotation.processor.util.ElementUtils.isInterface;
import static io.microsphere.annotation.processor.util.MethodUtils.findDeclaredMethods;
import static io.microsphere.annotation.processor.util.MethodUtils.getMethodName;
import static io.microsphere.annotation.processor.util.MethodUtils.getMethodParameterTypeNames;
import static io.microsphere.collection.MapUtils.newHashMap;
import static io.microsphere.collection.MapUtils.newLinkedHashMap;
import static io.microsphere.collection.Sets.ofSet;
import static io.microsphere.constants.SymbolConstants.DOT;
import static io.microsphere.constants.SymbolConstants.GREATER_THAN;
import static io.microsphere.constants.SymbolConstants.GREATER_THAN_CHAR;
import static io.microsphere.constants.SymbolConstants.LESS_THAN;
import static io.microsphere.lang.function.ThrowableSupplier.execute;
import static io.microsphere.redis.util.RedisCommandUtils.buildMethodIndex;
import static io.microsphere.redis.util.RedisCommandUtils.getRedisCommands;
import static io.microsphere.redis.util.RedisCommandUtils.getRedisWriteCommands;
import static io.microsphere.reflect.MethodUtils.findMethod;
import static io.microsphere.text.FormatUtils.format;
import static io.microsphere.util.ArrayUtils.arrayToString;
import static io.microsphere.util.ArrayUtils.length;
import static io.microsphere.util.StringUtils.substringBetween;
import static javax.lang.model.SourceVersion.latest;
import static javax.lang.model.element.ElementKind.METHOD;
import static javax.lang.model.element.NestingKind.TOP_LEVEL;
import static javax.tools.StandardLocation.CLASS_PATH;
import static javax.tools.ToolProvider.getSystemJavaCompiler;
import static org.springframework.util.ClassUtils.forName;
import static org.yaml.snakeyaml.DumperOptions.FlowStyle.BLOCK;

/**
 * The {@link Doclet} class for Spring Data Redis Metadata Generation.
 * <p>
 * Spring Data Redis Metadata YAML file will be generated by parsing the JavaDoc from the Spring Data Redis Java source code,
 * whose format is compatible with The Java Model {@link RedisMetadata}.
 * <p>
 * The metadata file will be generated to the specified path, which can be specified by the option {@link #METADATA_FILE_OPTION_NAME}.
 *
 * @author <a href="mailto:mercyblitz@gmail.com">Mercy</a>
 * @see Doclet
 * @see RedisMetadata
 * @see SpringDataRedisMetadataGenerator
 * @since 1.0.0
 */
public class SpringDataRedisMetadataGenerationDoclet implements Doclet {

    public static final String METADATA_FILE_OPTION_NAME = "--metadata-file";

    /**
     * The metadata key of Spring Data Redis Version
     */
    public static final String VERSION_KEY = "version";

    /**
     * The metadata key of Spring Data Redis Command Methods
     */
    public static final String METHODS_KEY = "methods";

    /**
     * The metadata key of Spring Data Redis Command Interface Name
     */
    public static final String INTERFACE_NAME_KEY = "interfaceName";

    /**
     * The metadata key of Spring Data Redis Command Method Index
     */
    public static final String INDEX_KEY = "index";

    /**
     * The metadata key of Spring Data Redis Command Method Name
     */
    public static final String METHOD_NAME_KEY = "methodName";

    /**
     * The metadata key of Spring Data Redis Command Method Parameters' types
     */
    public static final String METHOD_PARAMETER_TYPES_KEY = "parameterTypes";

    /**
     * The metadata key of Spring Data Redis Command Method Command Name
     */
    public static final String COMMAND_KEY = "command";

    /**
     * The metadata key of Spring Data Redis Method Command Flag
     */
    public static final String WRITE_KEY = "write";

    private Locale locale;

    private Logger logger;

    private Set<String> redisCommands;

    private Set<String> redisWriteCommands;

    private Set<String> supportedCommands;

    private Set<String> supportedWriteCommands;

    private File metadataFile;

    private JavaCompiler javaCompiler;

    private DocletEnvironment environment;

    private Map<String, Class<?>> classesCache;

    @Override
    public void init(Locale locale, Reporter reporter) {
        this.locale = locale;
        this.logger = new ReporterLoggerAdapter(getName(), reporter);
        this.redisCommands = getRedisCommands();
        this.redisWriteCommands = getRedisWriteCommands();
        this.supportedCommands = new HashSet<>();
        this.supportedWriteCommands = new HashSet<>();
        this.javaCompiler = getSystemJavaCompiler();
        this.classesCache = newHashMap(256);
    }

    @Override
    public String getName() {
        return getClass().getSimpleName();
    }

    @Override
    public Set<? extends Option> getSupportedOptions() {
        return ofSet(
                new StandardOption(METADATA_FILE_OPTION_NAME, 1,
                        null,
                        "The metadata file path to generate Spring Data Redis Metadata") {
                    @Override
                    public boolean process(String option, List<String> arguments) {
                        String metadataFilePath = arguments.get(0);
                        metadataFile = new File(metadataFilePath);
                        return true;
                    }
                }
        );
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return latest();
    }

    @Override
    public boolean run(DocletEnvironment environment) {
        this.environment = environment;
        generateSpringDataRedisMetadata(environment);
        return true;
    }

    protected void generateSpringDataRedisMetadata(DocletEnvironment environment) {
        DocTrees docTrees = environment.getDocTrees();

        Map<String, Object> springDataRedisMetadata = newLinkedHashMap();
        springDataRedisMetadata.put(VERSION_KEY, getSpringDataRedisVersion());

        List<Map<String, Object>> redisMethodMetadataMapList = new LinkedList<>();
        springDataRedisMetadata.put(METHODS_KEY, redisMethodMetadataMapList);

        RedisCommandMethodVisitor redisCommandMethodVisitor = new RedisCommandMethodVisitor(redisMethodMetadataMapList);

        Set<? extends Element> specifiedElements = environment.getSpecifiedElements();
        for (Element element : specifiedElements) {
            ElementKind kind = element.getKind();
            if (isInterface(kind)) {
                TypeMirror type = element.asType();
                if (!isTopClass(element)) {
                    continue;
                }
                if (!hasMethods(type)) {
                    continue;
                }
                element.accept(redisCommandMethodVisitor, docTrees);
            }
        }

        validateIndex(redisMethodMetadataMapList);

        validateMethod(redisMethodMetadataMapList);

        this.logger.info("All Redis commands(size : {} , write : {}), the supported Spring Data Redis commands(size : {} , write : {})",
                this.redisCommands.size(), this.redisWriteCommands.size(), this.supportedCommands.size(), this.supportedWriteCommands.size());
        this.logger.info("All Redis commands : {}", this.redisCommands);
        this.logger.info("All Redis write commands : {}", this.redisWriteCommands);
        this.logger.info("The supported Spring Data Redis commands : {}", this.supportedCommands);
        this.logger.info("The supported Spring Data Redis write commands : {}", this.supportedWriteCommands);

        writeSpringDataRedisMetadata(springDataRedisMetadata);
    }

    private String getSpringDataRedisVersion() {
        return RedisCommands.class.getPackage().getImplementationVersion();
    }

    private boolean isTopClass(Element element) {
        TypeElement typeElement = (TypeElement) element;
        NestingKind nestingKind = typeElement.getNestingKind();
        return TOP_LEVEL == nestingKind;
    }

    private boolean hasMethods(TypeMirror type) {
        return !findDeclaredMethods(type).isEmpty();
    }

    private String[] resolveMethodParameterClassNames(ExecutableElement methodElement) {
        ClassLoader classLoader = getClassLoader();
        String[] methodParameterTypeNames = getMethodParameterTypeNames(methodElement);
        int length = length(methodParameterTypeNames);
        String[] methodParameterClassNames = new String[length];
        for (int i = 0; i < length; i++) {
            String methodParameterTypeName = methodParameterTypeNames[i];
            String methodParameterClassName = normalizeClassName(methodParameterTypeName);

            Class<?> methodParameterClass = loadClass(classLoader, methodParameterClassName);
            if (methodParameterClass == null) {
                methodParameterClass = deduceMethodParameterClass(methodElement, methodParameterClassName, i, length, classLoader);
            }

            methodParameterClassNames[i] = methodParameterClass.getName();
        }
        return methodParameterClassNames;
    }

    private String normalizeClassName(String typeName) {
        int genericTypeStartIndex = typeName.indexOf(LESS_THAN);
        if (genericTypeStartIndex > 0) {
            String className = typeName.substring(0, genericTypeStartIndex);
            int lastIndex = typeName.length() - 1;
            if (typeName.charAt(lastIndex) == GREATER_THAN_CHAR) {
                return className;
            }
            int genericTypeEndIndex = typeName.lastIndexOf(GREATER_THAN);
            if (genericTypeEndIndex > genericTypeStartIndex) {
                String arrayTypeSymbol = typeName.substring(genericTypeEndIndex + 1);
                return className + arrayTypeSymbol;
            }
        }
        return typeName;
    }

    private Class<?> deduceMethodParameterClass(ExecutableElement methodElement, String parameterClassName,
                                                int parameterIndex, int parameterCount, ClassLoader classLoader) {
        Element declaredElement = methodElement.getEnclosingElement();
        String className = declaredElement.toString();
        JavaFileManager javaFileManager = this.getJavaFileManager();

        return execute(() -> {
            JavaFileObject javaFileObject = getJavaFileObject(className);
            JavacTask task = (JavacTask) javaCompiler.getTask(null, javaFileManager, null, null,
                    ofSet(className), ofSet(javaFileObject));

            String methodName = methodElement.getSimpleName().toString();

            ValueHolder<String> methodParameterClassNameHolder = new ValueHolder<>();

            TreeScanner<Void, Void> treeScanner = new TreeScanner<>() {

                @Override
                public Void visitMethod(MethodTree node, Void unused) {
                    Name name = node.getName();
                    List<? extends VariableTree> parameters = node.getParameters();
                    if (name.contentEquals(methodName) && parameters.size() == parameterCount) {
                        VariableTree parameter = parameters.get(parameterIndex);
                        Tree parameterType = parameter.getType();
                        if (parameterClassName.equals(parameterType.toString())) {
                            List<? extends TypeParameterTree> typeParameters = node.getTypeParameters();
                            for (TypeParameterTree typeParameter : typeParameters) {
                                Name typeParameterName = typeParameter.getName();
                                if (typeParameterName.contentEquals(parameterClassName)) {
                                    List<? extends Tree> bounds = typeParameter.getBounds();
                                    Tree bound = bounds.get(0);
                                    String className = bound.toString();
                                    if (!className.contains(DOT)) {
                                        className = "java.lang." + className;
                                    }
                                    methodParameterClassNameHolder.setValue(className);
                                }
                            }
                        }
                    }
                    return null;
                }
            };

            for (CompilationUnitTree unitTree : task.parse()) {
                unitTree.accept(treeScanner, null);
            }

            String methodParameterClassName = methodParameterClassNameHolder.getValue();
            return loadClass(classLoader, methodParameterClassName);
        });
    }

    private JavaFileManager getJavaFileManager() {
        return this.environment.getJavaFileManager();
    }

    private ClassLoader getClassLoader() {
        JavaFileManager javaFileManager = getJavaFileManager();
        return javaFileManager.getClassLoader(CLASS_PATH);
    }

    private JavaFileObject getJavaFileObject(String className) throws IOException {
        JavaFileManager javaFileManager = this.getJavaFileManager();
        return javaFileManager.getJavaFileForInput(CLASS_PATH, className, JavaFileObject.Kind.SOURCE);
    }

    private void writeSpringDataRedisMetadata(Map<String, Object> springDataRedisMetadata) {
        Yaml yaml = createYaml();
        try (FileWriter writer = new FileWriter(metadataFile);
             FileReader reader = new FileReader(metadataFile)) {
            yaml.dump(springDataRedisMetadata, writer);
            // Check the consistency
            RedisMetadata redisMetadata = yaml.loadAs(reader, RedisMetadata.class);
            this.logger.info("Spring Data Redis Metadata : {}", redisMetadata);
        } catch (IOException e) {
            this.logger.error("Can't write Spring Data Redis Metadata to file : {}", metadataFile, e);
        }
    }

    private Yaml createYaml() {
        DumperOptions options = new DumperOptions();
        options.setDefaultFlowStyle(BLOCK);
        options.setPrettyFlow(true);
        return new Yaml(options);
    }

    void validateCommand(String interfaceName, String signature, String resolvedCommand) {
        if (!redisCommands.contains(resolvedCommand)) {
            throwsException("The Redis command can't be resolved by the JavaDoc of {}#{} , actual : {}",
                    interfaceName, signature, resolvedCommand);
        }
    }

    void validateIndex(List<Map<String, Object>> redisMethodMetadataMapList) {
        Set<Integer> indices = new HashSet<>();
        for (Map<String, Object> redisMethodMetadataMap : redisMethodMetadataMapList) {
            Integer index = (Integer) redisMethodMetadataMap.get(INDEX_KEY);
            if (!indices.add(index)) {
                String methodName = (String) redisMethodMetadataMap.get(METHOD_NAME_KEY);
                String[] parameterTypes = (String[]) redisMethodMetadataMap.get(METHOD_PARAMETER_TYPES_KEY);
                throwsException("The index of Redis Command Method[name : '{}' , parameter types : {}]  : {} is duplicated",
                        methodName, arrayToString(parameterTypes), index);
            }
        }
    }

    void validateMethod(List<Map<String, Object>> redisMethodMetadataMapList) {
        ClassLoader classLoader = getClassLoader();
        for (Map<String, Object> redisMethodMetadataMap : redisMethodMetadataMapList) {
            String interfaceName = (String) redisMethodMetadataMap.get(INTERFACE_NAME_KEY);
            String methodName = (String) redisMethodMetadataMap.get(METHOD_NAME_KEY);
            String[] parameterTypes = (String[]) redisMethodMetadataMap.get(METHOD_PARAMETER_TYPES_KEY);

            Class<?> interfaceClass = loadClass(classLoader, interfaceName);
            Class<?>[] parameterClasses = new Class<?>[parameterTypes.length];
            for (int i = 0; i < parameterTypes.length; i++) {
                String parameterType = parameterTypes[i];
                parameterClasses[i] = loadClass(classLoader, parameterType);
            }

            Method method = findMethod(interfaceClass, methodName, parameterClasses);
            if (method == null) {
                throwsException("Can't find the method[name : '{}' , parameter types : {}] in interface[name : '{}']",
                        methodName, arrayToString(parameterTypes), interfaceName);
            }
        }
    }

    private Class<?> loadClass(ClassLoader classLoader, String className) {
        return loadClass(classLoader, className, e -> {
            logger.warn("The ClassLoader[{}] can't load the Class[name : '{}']", classLoader, className);
            return null;
        });
    }

    private Class<?> loadClass(ClassLoader classLoader, String className, Function<Throwable, Class<?>> exceptionHandler) {
        return this.classesCache.computeIfAbsent(className, k -> {
            try {
                return forName(className, classLoader);
            } catch (ClassNotFoundException e) {
                return exceptionHandler.apply(e);
            }
        });
    }

    private void throwsException(String messagePattern, Object... args) {
        throw new IllegalStateException(format(messagePattern, args));
    }

    class RedisCommandMethodVisitor extends ElementScanner9<Void, DocTrees> {

        private final List<Map<String, Object>> redisMethodMetadataMapList;

        RedisCommandMethodVisitor(List<Map<String, Object>> redisMethodMetadataMapList) {
            this.redisMethodMetadataMapList = redisMethodMetadataMapList;
        }

        @Override
        public Void scan(Element e, DocTrees docTrees) {
            ElementKind kind = e.getKind();
            if (METHOD.equals(kind)) {
                ExecutableElement methodElement = (ExecutableElement) e;
                DocCommentTree dcTree = docTrees.getDocCommentTree(e);
                String interfaceName = methodElement.getEnclosingElement().toString();
                String methodName = getMethodName(methodElement);
                String[] methodParameterTypeNames = resolveMethodParameterClassNames(methodElement);
                int index = buildMethodIndex(interfaceName, methodName, methodParameterTypeNames);

                Map<String, Object> redisMethodMetadataMap = newLinkedHashMap();
                redisMethodMetadataMap.put(INDEX_KEY, index);
                redisMethodMetadataMap.put(INTERFACE_NAME_KEY, interfaceName);
                redisMethodMetadataMap.put(METHOD_NAME_KEY, methodName);
                redisMethodMetadataMap.put(METHOD_PARAMETER_TYPES_KEY, methodParameterTypeNames);

                if (dcTree != null) {
                    dcTree.accept(new RedisCommandMethodDocumentVisitor(redisMethodMetadataMap), methodElement);
                }

                this.redisMethodMetadataMapList.add(redisMethodMetadataMap);
                logger.info("Redis Method Metadata : {}", redisMethodMetadataMap);
            }
            return null;
        }
    }

    class RedisCommandMethodDocumentVisitor extends DocTreeScanner<Void, ExecutableElement> {

        private static final String DOC_OPEN = "Redis Documentation:";

        private static final String DOC_CLOSE = "<";

        private final Map<String, Object> redisMethodMetadataMap;

        RedisCommandMethodDocumentVisitor(Map<String, Object> redisMethodMetadataMap) {
            this.redisMethodMetadataMap = redisMethodMetadataMap;
        }

        @Override
        public Void scan(DocTree t, ExecutableElement methodElement) {
            DocTree.Kind kind = t.getKind();
            if (SEE.equals(kind)) {
                String see = t.toString();
                String reference = substringBetween(see, DOC_OPEN, DOC_CLOSE);
                if (reference != null) {
                    String interfaceName = (String) this.redisMethodMetadataMap.get(INTERFACE_NAME_KEY);
                    String signature = methodElement.toString();
                    String resolvedCommand = reference.trim().toUpperCase(locale);
                    validateCommand(interfaceName, signature, resolvedCommand);

                    boolean write = redisWriteCommands.contains(resolvedCommand);
                    this.redisMethodMetadataMap.put(COMMAND_KEY, resolvedCommand);
                    this.redisMethodMetadataMap.put(WRITE_KEY, write);

                    supportedCommands.add(resolvedCommand);
                    if (write) {
                        supportedWriteCommands.add(resolvedCommand);
                    }
                }
            }
            return super.scan(t, methodElement);
        }
    }
}